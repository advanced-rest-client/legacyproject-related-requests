<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../app-pouchdb/pouchdb.html">
<link rel="import" href="../openable-panel-behavior/openable-panel-behavior.html">

<!--
An element that computes a list of requests related to a project.
It handles all request related events to update the list if the request object
change.

### Example
```html
<legacyproject-related-requests project-id="project-id"></legacyproject-related-requests>

<script>
document.querySelector('legacyproject-related-requests')
.addEventListener('project-related-requests-read', function(e) {
  console.log('Request for project: ', e.detail.projectId, ' are ready: ', e.detail.items);
});
</script>
```

@group Logic Elements
@element legacyproject-related-requests
-->
<script>
Polymer({
  is: 'legacyproject-related-requests',

  behaviors: [ArcBehaviors.OpenablePanelBehavior],

  /**
   * Fired when the query function finished querying for the data.
   *
   * @event project-related-requests-read
   * @param {String} projectId Current project ID
   * @param {Array} items List of requests related to the project.
   */

  properties: {
    /**
     * An ID of the legacy project. Once changed it queries the datastore for
     * related requests.
     */
    projectId: String,
    /**
     * list of requests found for the project.
     */
    data: {
      type: Array,
      notify: true
    },
    /**
     * If `true` then it queries for whole request objects.
     * Otherwise it only returns the `name`, `_rev` and `_id` properties.
     */
    fullQuery: Boolean,
    // If set then query is performed
    querying: {
      type: Boolean,
      notify: true,
      readOnly: true
    }
  },

  get db() {
    return new PouchDB('saved-requests');
  },

  observers: [
    '_autoQuery(_isOpened, projectId)'
  ],

  attached: function() {
    this.listen(window, 'request-object-changed', '_requestObjectChanged');
    this.listen(window, 'request-object-deleted', '_requestObjectDeleted');
    this.listen(window, 'request-objects-deleted', '_requestObjectsDeleted');
    this.listen(window, 'request-objects-restored', '_requestObjectsRestored');
  },

  detached: function() {
    this.unlisten(window, 'request-object-changed', '_requestObjectChanged');
    this.unlisten(window, 'request-object-deleted', '_requestObjectDeleted');
    this.unlisten(window, 'request-objects-deleted', '_requestObjectsDeleted');
    this.unlisten(window, 'request-objects-restored', '_requestObjectsRestored');
  },

  _dispatchReadEvent: function(requests, projectId) {
    this.fire('project-related-requests-read', {
      projectId: projectId,
      items: requests
    });
  },
  /**
   * Automatically run function when either `opened` or `projectId` change.
   */
  _autoQuery: function(opened, projectId) {
    if (!opened) {
      return;
    }
    this.query(projectId)
    .then(requests => {
      this.set('data', requests);
      this._dispatchReadEvent(requests, projectId);
    })
    .catch(cause => {
      this.fire('error', {
        message: cause.message
      });
    });
  },
  /**
   * Queries the datastore for related requests list for the project.
   *
   * @param {String} id Project ID
   * @return {Promise} Promise resolved to the list of related to project
   * requests.
   */
  query: function(id) {
    if (!id) {
      return Promise.reject(new Error('The "id" argument is missing'));
    }
    this._setQuerying(true);
    var db = this.db;
    return db.allDocs()
    .then(response => this._filterRequests(response, id))
    .then(response => Promise.all(response.map(item => db.get(item.id))))
    .then(requests => this._setDataScope(requests))
    .then(requests => this._prepareData(requests))
    .then(requests => {
      this._setQuerying(false);
      return requests;
    })
    .catch(cause => {
      this._setQuerying(false);
      this.fire('app-log', {
        'message': ['Query for project\'s related requests', cause],
        'level': 'error'
      });
      var message;
      if (cause.message) {
        message = cause.message;
      } else {
        message = JSON.stringify(cause);
      }
      this.fire('send-analytics', {
        type: 'exception',
        description: message,
        fatal: true
      });
      console.error('Query for project\'s related requests', cause);
      throw cause;
    });
  },
  /**
   * Filters request list returned by the query to ones related to current
   * request.
   * @param {Object} dbResponse PouchDB query response
   * @param {String} id Project ID
   * @return {Array} Filtered list of requests that are related to the project
   */
  _filterRequests: function(dbResponse, id) {
    return dbResponse.rows.filter(item => item.id.indexOf(id) !== -1);
  },
  /**
   * Perpares request objects depending on the `fullQuery` property.
   * If the property is set this does nothing. Otherwise this returns the
   * `name`, `_id` and `_rev` properties in the list of objects.
   *
   * @param {Array} list List of request objects
   * @return {Array} List of requests with requested scope.
   */
  _setDataScope: function(list) {
    if (this.fullQuery) {
      return list;
    }
    return list.map(item => {
      return {
        _id: item._id,
        _rev: item._rev,
        name: item.name
      };
    });
  },
  /**
   * Sorts requests list by `projectOrder` property. Also, maps  `_id` to `id`
   * so some legacy views can support this data.
   *
   * @param {Array} list List of request objects
   * @return {Array} Sorted list of requests
   */
  _prepareData: function(list) {
    if (!list.length) {
      return [];
    }
    list.sort((a, b) => {
      if (a.projectOrder > b.projectOrder) {
        return 1;
      }
      if (a.projectOrder < b.projectOrder) {
        return -1;
      }
      if (a.name > b.name) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      }
      return 0;
    });
    return list.map(item => {
      item.id = item._id;
      return item;
    });
  },
  /**
   * Handler for the `request-object-changed` event.
   * If the event is not cancelable and its `legacyProject` property equal current
   * project ID then it updates/adds request to the `data` list.
   */
  _requestObjectChanged: function(e) {
    if (e.cancelable) {
      // not yet saved
      return;
    }
    var request = e.detail.request;
    if (!request || !request.legacyProject || request.legacyProject !== this.projectId) {
      return;
    }
    var items = this.data;
    if (!items || !items.length) {
      this.set('data', [request]);
      this._dispatchReadEvent(this.data, this.projectId);
      return;
    }
    var oldId = e.detail.oldId;
    var existing = items.findIndex(item => item._id === oldId);
    if (existing === -1) {
      items.push(request);
    } else {
      items[existing] = e.detail.request;
    }
    items = this._prepareData(items);
    this.set('data', items);
  },
  /**
   * Handler for the `request-object-deleted` event. Removes a request from the
   * `data` list if removed item is on the list.
   */
  _requestObjectDeleted: function(e) {
    if (e.cancelable) {
      // not yet saved
      return;
    }
    if (!e.detail.id) {
      return;
    }
    this._checkDeleted([e.detail.id]);
  },
  /**
   * Handler for the `request-objects-deleted` event. Removes deleted requests
   * from the `data` list if they are on the list.
   */
  _requestObjectsDeleted: function(e) {
    if (e.cancelable) {
      // not yet saved
      return;
    }
    var ids = e.detail.items;
    if (!ids || !ids.length) {
      return;
    }
    this._checkDeleted(ids);
  },
  /**
   * Checks if any of the removed items is on current `data` list. Removes
   * items that are in the `ids` list.
   * @param {Array<String>} ids List of removed items IDs.
   */
  _checkDeleted: function(ids) {
    var items = this.data;
    if (!items || !items.length) {
      return;
    }
    for (let i = items.length - 1; i >= 0; i--) {
      if (~ids.indexOf(items[i]._id)) {
        this.splice('data', i, 1);
      }
    }
  }
});
</script>
